<html>
	<head>
		<link rel='stylesheet' type='text/css' href='/brickbreaker.css'/>		
	</head>
	<body>

		<div id='game'>
			<div id='ball'></div>
			<div id='paddle'></div>
		</div>
    <div id='message'></div>

	<script src="https://code.jquery.com/jquery-3.3.1.min.js"
					integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
				  crossorigin="anonymous"></script>

  <script src='BrickBreaker.js'></script>
  <script src='Paddle.js'></script>
  <script src='Brick.js'></script>
  <script src='InitView.js'></script>
  <script src='MovePaddleHandler.js'></script>
  <script src='QuadTreeNode.js'></script>

  <script>

  	$(function() {  		

  		const game = new BrickBreaker(20, 20, 300, 500, 5, 10, 20, 40, 10);
  		InitView(game);

  		const mouseMoveHandlers = (function() {
  			const paddle = $('#paddle');
  			const container = $('#game');
  			const point = {'x': null, 'y': null};
  			return [function(evt) { MovePaddleHandler(game, point, paddle, container, evt); },
  							function() { point.x = null, point.y = null}]
  		})();

  		$(document).on('mousedown touchstart', function(evt) {
	  		$(document).on('mousemove touchmove', mouseMoveHandlers[0]);
  		});	

  		$(document).on('mouseup touchend', function(evt) {
  			mouseMoveHandlers[1]();
	  		$(document).off('mousemove touchmove', mouseMoveHandlers[0]);
  		});	


  		const moveBall = (function() {

  			const ball = $('#ball');
  			const container = $('#game');
				const containerWidth = container.css('width').slice(0, -2);
        const containerRight = Number(containerWidth); // left is zero b/c of relative positioning
				const containerHeight = Number(container.css('height').slice(0, -2));

				let theta = Math.PI / 4;
        let vector = {
          'velocity': 2,
          'theta': 3.14 / 4,
          'x': 2 * Math.cos(3.14 / 4),
          'y': 2 * Math.sin(3.14 / 4),
          'slope': Math.atan(1),
          'b': Number(ball.css('bottom').slice(0, -2)) - 
                Math.atan(1) * Number(ball.css('left').slice(0, -2))
        };

  			return function() {

  				const currentX = Number(ball.css('left').slice(0, -2));
  				const currentY = Number(ball.css('bottom').slice(0, -2));

          let impactedBrick = game.detectBrickCollision(currentX, containerHeight - currentY);

          if (impactedBrick != null) {
            switch(impactedBrick.wallNearest(currentX, currentY, vector.slope, vector.b)) {
              case -1:
                console.log('wall impact error');
                break;
              case 1:
                // bottom from below
                vector.y *= -1 + (Math.random() - 0.5) / 4; 
                break;
              case 2:
                // left wall from left
                vector.x *= -1 + (Math.random() - 0.5) / 4; 
                break;
              case 3:
                // top from above
                vector.y *= -1 + (Math.random() - 0.5) / 4; 
                break;
              case 4:
                // right wall from right
                vector.x *= -1 + (Math.random() - 0.5) / 4; 
                break;
            }
            vector.slope = Math.atan(vector.y / vector.x);
            vector.b = currentY - Math.atan(1) * currentX;
            impactedBrick.hide();
            $(`div[brick=${impactedBrick.id}]`).css('visibility', 'hidden');
          }

          // left wall collision
  				if (currentX + vector.x < 0) {            
            vector.x *= -1 + (Math.random() - 0.5) / 4; 
            vector.slope = Math.atan(vector.y / vector.x);
            vector.b = currentY - Math.atan(1) * currentX;
          }

          // right wall collision
          if (currentX + vector.x > containerRight) {
            vector.x *= -1 + (Math.random() - 0.5) / 4; 
            vector.slope = Math.atan(vector.y / vector.x);
            vector.b = currentY - Math.atan(1) * currentX;
          }

          // top wall collision
          if (currentY + vector.y > containerHeight) {
            vector.y *= -1 + (Math.random() - 0.5) / 4; 
            vector.slope = Math.atan(vector.y / vector.x);
            vector.b = currentY - Math.atan(1) * currentX;
          }

          // bottom wall collision
          if (currentY + vector.y < 0) {
            $('#message').text('Game Over!');
            window.clearInterval(gamePlayCallbackID);
          }

          const paddleHitPosition = game.paddle.detectPaddleCollision(currentX, currentY);

          if (paddleHitPosition >= 0) {
            vector.y *= -1 + (Math.random() - 0.5) / 4; 
            vector.slope = Math.atan(vector.y / vector.x);
            vector.b = currentY - Math.atan(1) * currentX;            
          }

  				ball.css('left', String(currentX + vector.x) + 'px');
  				ball.css('bottom', String(currentY + vector.y) + 'px');

  			}

  		})()

	  	const gamePlayCallbackID = window.setInterval(moveBall, 10);

  	});

  </script>

	</body>
</html>





